diff a/cpp_windows/humanTracking/humanTracking/DepthSensor.cpp b/cpp_windows/humanTracking/humanTracking/DepthSensor.cpp	(rejected hunks)
@@ -52,24 +52,47 @@
 	ConvertPXCImageToOpenCVMat(sample->depth, depthMat);
 
 	// resize 640 x 480
-	cv::resize(*depthMat, *depthMat, cv::Size(), 2.0, 2.0);
+	//cv::resize(*depthMat, *depthMat, cv::Size(), 2.0, 2.0);
 }
 
-//void DepthSensor::getWorld(int frame, std::vector<Intel::RealSense::PointF32>& wcords) {
-//	// Set to work on every 3rd frame of data
-//	sm->QueryCaptureManager()->SetFrameByIndex(frame);
-//	sm->FlushFrame();
-//
-//	// Ready for the frame to be ready
-//	pxcStatus sts = sm->AcquireFrame(true);
-//	if (sts < PXC_STATUS_NO_ERROR) return;
-//
-//	// Retrieve the sample and work on it. The image is in sample->color.
-//	PXCCapture::Sample* sample = sm->QuerySample();
-//
-//	//sample->depth
-//	projection.DepthToWorld(sample->depth, sample->depth, wcords);
-//}
+// from top perspective view
+//cv::Mat m_perspectiveMat = (cv::Mat_<double>(4, 4) << 1.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,
+//													  0.00000000e+00, 7.07106781e-01, 7.07106781e-01, 0.00000000e+00,
+//													  0.00000000e+00, -7.07106781e-01, 7.07106781e-01, 0.00000000e+00,
+//													  0.00000000e+00, 2.47487373e+03, 2.47487373e+03, 1.00000000e+00);
+cv::Mat m_perspectiveMat = (cv::Mat_<double>(4, 4) << 1.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,
+													  0.00000000e+00, 7.07106781e-01, -7.07106781e-01, 0.00000000e+00,
+													  0.00000000e+00, 7.07106781e-01, 7.07106781e-01, 0.00000000e+00,
+													  0.00000000e+00, 2.47487373e+03, -2.47487373e+03, 1.00000000e+00);
+static cv::Mat localMat(4, 1, CV_64FC1);
+static cv::Mat worldMat(4, 1, CV_64FC1);
+void DepthSensor::cameraToWorld(PXCPoint3DF32 *camera, PXCPoint3DF32 *world) {
+	for (int i = 0; i < 320 * 240; i++) {
+		localMat.at<double>(0, 0) = camera[i].x;
+		localMat.at<double>(1, 0) = camera[i].y;
+		localMat.at<double>(2, 0) = camera[i].z;
+		localMat.at<double>(3, 0) = 1;
+
+		worldMat = m_perspectiveMat * localMat;
+
+		world[i].x = worldMat.at<double>(0, 0);
+		world[i].y = worldMat.at<double>(1, 0);
+		world[i].z = worldMat.at<double>(2, 0);
+	}
+}
+
+void DepthSensor::cameraToWorldPoint(PXCPoint3DF32 *camera, PXCPoint3DF32 *world) {
+	localMat.at<double>(0, 0) = camera->x;
+	localMat.at<double>(1, 0) = camera->y;
+	localMat.at<double>(2, 0) = camera->z;
+	localMat.at<double>(3, 0) = 1;
+
+	worldMat = m_perspectiveMat * localMat;
+
+	world->x = worldMat.at<double>(0, 0);
+	world->y = worldMat.at<double>(1, 0);
+	world->z = worldMat.at<double>(2, 0);
+}
 
 void DepthSensor::ConvertPXCImageToOpenCVMat(PXCImage *inImg, cv::Mat *outImg) {
 	int cvDataType;
